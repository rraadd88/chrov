# AUTOGENERATED! DO NOT EDIT! File to edit: ../../modules_nbs/fig_mat.ipynb.

# %% auto 0
__all__ = ["get_gid_info", "Plot_levels"]

# %% ../../modules_nbs/fig_mat.ipynb 2
import logging
import matplotlib.pyplot as plt

from chrov.utils import get_src_path

import pandas as pd

import functools

# %run ../modules/plot/mat.py
from chrov.plot.mat import plot_tri


@functools.cache
def get_gid_info(gid):
    import requests
    import sys

    server = "https://rest.ensembl.org"
    ext = f"/lookup/id/{gid}?format=full"

    r = requests.get(server + ext, headers={"Content-Type": "application/json"})

    if not r.ok:
        r.raise_for_status()
        sys.exit()

    decoded = r.json()
    # print(repr(decoded))
    return decoded


class Plot_levels:
    def __init__(
        self,
        gene_id,  # ='ENSG00000187634',
        species="homo sapiens",
        ensembl_release=112,
        # chrom=1, ## infer
        in_dir_name="inputs",
        show_labels=True,
        test=False,
    ):
        self.test = test
        self.in_dir_name = in_dir_name
        self.gene_id = gene_id
        self.species = species
        self.ensembl_release = ensembl_release

        cytobands = pd.read_table(
            f"{get_src_path()}/modules/{self.in_dir_name}/cytobands.tsv",
            index_col=[0],
        )

        mdata_gid = get_gid_info(
            gid="ENSG00000187634",
        )
        self.chrom = mdata_gid["seq_region_name"]

        from functools import partial
        from chrov.viz.chrom import plot_chroms

        self.genome = partial(
            plot_chroms,
            data=cytobands,
            arc=False,
            show_labels=False,
            label_y=0.05,
            test=self.test,
            figsize=[20, 1],
        )

        self.chromosome = partial(
            plot_chroms,
            data=cytobands.query(expr=f"`chromosome` == '{self.chrom}'"),
            arc=False,
            show_labels=False,
            figsize=[4, 0.2],
            test=self.test,
        )
        # from dups.viz import plot_forms

        # for biotype in ["t","p"]:
        #     for layout in [None, "blocks"]:
        #         fig, ax = plt.subplots(
        #             figsize=[3, figh],
        #         )
        kws_domains = dict(
            gene_id=gene_id,
            species=species,
            ensembl_release=ensembl_release,
            # order='longest',
            # show_labels=show_labels,
        )
        from chrov.annots import get_ts_data
        from chrov.domains import get_ds_data

        self.get_ts_data = partial(
            get_ts_data,
            suffix="b",
            protein_coding=True,
            cds_prefix="c",
            **kws_domains,
        )
        self.get_ds_data = partial(
            get_ds_data,
            suffix="b",
            **kws_domains,
        )

        # flt='longest',
        order = (
            self.get_ts_data(
                # **kws_domains,
            )
            .sort_values("t.length", ascending=False)["t.id"]
            .tolist()[:1]
        )
        logging.warning(f"longest isoform ({order[0]}) will be shown ..")
        # kws_domains['order']=order
        from chrov.domains import plot_domains as plot_forms

        self.gene = partial(
            plot_forms,
            biotype="t",
            layout=None,
            order=order,
            **kws_domains,
        )

        self.isoform = partial(
            plot_forms,
            biotype="t",
            layout="blocks",
            order=order,
            show_lines=True,
            **kws_domains,
        )

        self.protein = partial(
            plot_forms,
            biotype="p",
            layout=None,
            # layout='blocks',
            order=order,
            **kws_domains,
        )

        x_longest_domain = (
            self.get_ds_data(
                layout=None,
            )
            .sort_values("d.length", ascending=False)
            .iloc[0, :]
        )
        self.domain_ = partial(
            plot_forms,
            biotype="p",
            layout=None,
            order=order,
            **kws_domains,
        )

        def domain(
            **kws,
        ):
            ax = self.domain_(
                **kws,
            )
            ax.set(
                xlim=[
                    x_longest_domain["d.start"],
                    x_longest_domain["d.end"],
                ]
            )
            return ax

        self.domain = domain

        def plot(
            levels: dict,
            height_ratios=[3, 1],
            # sharex=True,
            # wspace=0,
            show_title=False,
            figsize=[3, 1.5],
            outd=None,
            kws_to_plot={},
            **kws_mat,
        ):
            from roux.viz.io import to_plot

            for level in levels:
                fig, axd = plt.subplot_mosaic(
                    [["data"], ["region"]],
                    height_ratios=height_ratios,
                    # sharex=True,
                    # wspace=0,
                    figsize=figsize,
                )
                # ax=plot_genome(
                ax = getattr(
                    # plot_levels,
                    self,
                    level,
                )(
                    ax=axd["region"],
                )
                _ = ax.set(
                    # ylim=[-0.1,0.1],
                    xticks=[],
                    xticklabels=[],
                    xlabel=None,
                )
                # axd['region'].plot([0,1],[0,1])
                # axd['data'].plot([0,1],[0,1])
                ax = plot_tri(
                    levels[level],
                    # cmap='Blues',
                    ax=axd["data"],
                    proportional=False,
                    **kws_mat,
                )
                if show_title:
                    ax.set_title(
                        level,
                        va="top",
                        y=0.75,
                    )
                plt.subplots_adjust(hspace=0.05)
                if outd is not None:
                    to_plot(
                        **{
                            **dict(
                                plotp=f"{outd}/{level}.png",
                            ),
                            **kws_to_plot,
                        }
                    )
                # break
            return ax

        self.plot = plot
